<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org"
     xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
     layout:decorate="~{include/layout}">
     <th:block layout:fragment="content">
     <link th:href="@{/css/authorization/authorizationList.css}" rel="stylesheet" type="text/css">
     <link th:href="@{/css/authorization/authorizationModal.css}" rel="stylesheet" type="text/css">
     <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.9.3/html2pdf.bundle.min.js"></script>
     <section>
	    <!-- CSRF 토큰 추가 -->
	    <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}" id="csrfToken">
	    <input type="hidden" id="authorNo" name="authorNo" th:value="${authorization != null ? authorization.authorNo : ''}" />

	    
	
	    <div class="main-content-custom">
	        <div id="section_wrap">
	            <div class="word">
	                <h3>기안 진행 목록</h3>
	            </div><br>
	            <div class="book_list">
	                <table class="table-custom">
	                    <colgroup>
	                        <col width="20%">
	                        <col width="30%">
	                        <col width="20%">
	                        <col width="20%">
	                    </colgroup>
	                    <thead>
	                        <tr>
	                            <th>기안일</th>
	                            <th>결재 양식</th>
	                            <th>제목</th>
	                            <th>상태</th>
	                        </tr>
	                    </thead>
	                    <tbody id="resultList">
	                        <th:block th:if="${resultList == null || #lists.isEmpty(resultList)}">
	                            <tr>
	                                <td colspan="4">해당되는 문서가 없습니다.</td>
	                            </tr>
	                        </th:block>
	                        <th:block th:if="${resultList != null && !#lists.isEmpty(resultList)}">
	                            <tr th:each="authorization : ${resultList}">
	                                <td th:text="${authorization.authorRegDate != null ? #temporals.format(authorization.authorRegDate, 'yyyy.MM.dd') : ''}"></td>
	                                <td th:text="${authorization.authorName != null ? authorization.authorName : 'N/A'}"></td>
	                                <td>
	                                    <a href="javascript:void(0);" th:text="${authorization.authTitle != null ? authorization.authTitle : '제목 없음'}" 
	                                       th:onclick="'openApprovalModal(' + ${authorization.authorNo} + ')'"></a>
	                                </td>
	                                <td th:text="${authorization.authorStatus == 'T' ? '임시 저장' 
	                                    : (authorization.authorStatus == 'P' ? '미승인' 
	                                    : (authorization.authorStatus == 'N' ? '반려' 
	                                    : (authorization.authorStatus == 'Y' ? '승인' 
	                                    : (authorization.authorStatus == 'R' ? '회수됨' : 'Unknown'))))}"></td>
	                            </tr>
	                        </th:block>
	                    </tbody>
	                </table>

					<!-- 기안 진행 목록 페이징 -->
					<div class="pagination" th:if="${draftPage.totalPages > 0}">
					    <!-- 이전 페이지 링크: 2 페이지 이상일 때만 표시 -->
					    <a th:href="@{/authorization/authorizationList(draftPage=${draftPage.pageable.pageNumber > 0 ? draftPage.pageable.pageNumber - 1 : 0}, completedPage=${completedPage.pageable.pageNumber})}" 
					       th:if="${draftPage.pageable.pageNumber > 0}">&lsaquo;</a>
					
					    <!-- 페이지 번호 반복 (1부터 totalPages까지) -->
					    <span th:each="i : ${#numbers.sequence(1, draftPage.totalPages)}">
					        <a th:text="${i}" 
					           th:href="@{/authorization/authorizationList(draftPage=${i - 1}, completedPage=${completedPage.pageable.pageNumber})}" 
					           th:classappend="${i == draftPage.pageable.pageNumber + 1} ? 'active'">1</a>
					    </span>
					
					    <!-- 다음 페이지 링크: 마지막 페이지가 아닐 때만 표시 -->
					    <a th:href="@{/authorization/authorizationList(draftPage=${draftPage.pageable.pageNumber + 1}, completedPage=${completedPage.pageable.pageNumber})}" 
					       th:if="${draftPage.pageable.pageNumber + 1 < draftPage.totalPages}">&rsaquo;</a>
					</div>
	                <br>
	
	                <!-- 완료된 문서 리스트 -->
	                <div class="word">
	                    <h3>완료 문서</h3> 
	                </div><br>
	                <div class="book_list">
	                    <table class="table-custom">
	                        <colgroup>
	                            <col width="20%">
	                            <col width="30%">
	                            <col width="20%">
	                            <col width="20%">
	                        </colgroup>
	                        <thead>
	                            <tr>
	                                <th>기안일</th>
	                                <th>결재 양식</th>
	                                <th>제목</th>
	                                <th>상태</th>
	                            </tr>
	                        </thead>
	                        <tbody id="completeList">
	                            <th:block th:if="${completedList == null || #lists.isEmpty(completedList)}">
	                                <tr>
	                                    <td colspan="4">완료된 문서가 없습니다.</td>
	                                </tr>
	                            </th:block>
	                            <th:block th:if="${completedList != null && !#lists.isEmpty(completedList)}">
	                                <tr th:each="authorization : ${completedList}">
	                                    <td th:text="${authorization.authorRegDate != null ? #temporals.format(authorization.authorRegDate, 'yyyy.MM.dd') : ''}"></td>
	                                    <td th:text="${authorization.authorName != null ? authorization.authorName : 'N/A'}"></td>
	                                    <td>
	                                        <a href="javascript:void(0);" 
											   th:text="${authorization.authTitle != null ? authorization.authTitle : '제목 없음'}" 
											   th:onclick="'openCompletedApprovalModal(' + ${authorization.authorNo} + '); clearNotification(' + ${authorization.authorNo} + ');'">
											</a>
	                                    </td>
										<td th:text="${authorization.authorStatus == 'Y' ? '승인' : (authorization.authorStatus == 'N' ? '반려' : (authorization.authorStatus == 'C' ? '확인' : 'Unknown'))}"></td>
	                            </th:block>
	                        </tbody>
	                    </table>
	                </div>

					<div class="pagination">
					    <!-- 이전 페이지 링크: 2 페이지 이상일 때만 표시 -->
					    <a th:href="@{/authorization/authorizationList(completedPage=${completedPage.pageable.pageNumber - 1})}" 
					       th:if="${completedPage.pageable.pageNumber > 0}">&lsaquo;</a>
					
					    <!-- 페이지 번호 반복 (현재 페이지 기준으로 앞뒤로 최대 3개) -->
					    <span th:each="i : ${#numbers.sequence(completedPage.pageable.pageNumber > 0 ? completedPage.pageable.pageNumber : 1, completedPage.pageable.pageNumber + 2 < completedPage.totalPages ? completedPage.pageable.pageNumber + 2 : completedPage.totalPages)}">
					        <a th:text="${i}" 
					           th:href="@{/authorization/authorizationList(completedPage=${i - 1})}" 
					           th:classappend="${i == completedPage.pageable.pageNumber + 1} ? 'active'">1</a>
					    </span>
					
					    <!-- 다음 페이지 링크: 마지막 페이지가 아닐 때만 표시 -->
					    <a th:href="@{/authorization/authorizationList(completedPage=${completedPage.pageable.pageNumber + 1})}" 
					       th:if="${completedPage.pageable.pageNumber + 1 < completedPage.totalPages}">&rsaquo;</a>
					</div>

	                <!-- 모달 창 -->
	                <div id="section_wrap">
	                    <form id="authorizationAddFrm" enctype="multipart/form-data">
	                        <div id="section" class="form-section">
	                            <input type="button" class="btn-custom" value="새 결재 진행" style="float:right;" onclick="openModal()">
	                            <!-- 모달 창 -->
	                            <div id="documentModal" class="modal-custom" style="display: none;">
	                                <h3>결재 양식 선택</h3>
	                                <table class="table-custom">
	                                    <thead>
	                                        <tr>
	                                            <th>양식</th>
	                                            <th>제목</th>
	                                        </tr>
	                                    </thead>
	                                    <tbody>
	                                        <tr onclick="selectDocument('연차 보고서', '/authOff/authOffCreate?type=1')">
	                                            <td>연차 보고서</td>
	                                            <td>연차 신청 합니다.</td>
	                                        </tr>
	                                        <tr onclick="selectDocument('지각 사유서', '/authLate/authLateCreate?type=2')">
	                                            <td>지각 사유서</td>
	                                            <td>지각 사유 제출 합니다.</td>
	                                        </tr>
	                                        <tr onclick="selectDocument('해외 출장 신청서', '/authTrip/authTripCreate?type=3')">
	                                            <td>해외 출장 신청서</td>
	                                            <td>해외 출장 신청 합니다.</td>
	                                        </tr>
	                                        <tr onclick="selectDocument('야근 신청서', '/authOvertime/authOvertimeCreate?type=4')">
	                                            <td>야근 신청서</td>
	                                            <td>야근 신청 합니다.</td>
	                                        </tr>
	                                        <tr onclick="selectDocument('외근 신청서', '/authOutside/authOutsideCreate?type=5')">
	                                            <td>외근 신청서</td>
	                                            <td>외근 신청 합니다.</td>
	                                        </tr>
	                                    </tbody>
	                                </table>
	                                <br>
	                                <input type="button" value="취소" class="btn-custom" onclick="closeModal()">
	                            </div>
	                            <!-- 모달 배경 -->
	                            <div id="modalBackground" class="modal-background-custom" style="display: none;"></div>
	                        </div>
	                    </form>
	                </div>
	            </div>
	        </div>
	    </div>
	</section>
        
        <!-- 결재 상태 모달 창 HTML -->
        <div id="approvalModal" class="modal-custom" style="display: none;"> 
          <div class="modal-content-custom"> 
            <span class="close">&times;</span>
            <h3>결재 상태 상세 화면</h3>
            
            <table class="table-custom"> 
              <thead>
                <tr>
                  <th>결재자</th>
                  <th>직급</th>
                  <th>상태</th>
                </tr>
              </thead>
              <tbody id="approversList">
                <!-- 결재자 상태가 여기에 동적으로 추가 -->
              </tbody>
            </table>

            <table class="table-custom"> 
              <thead>
                <tr>
                  <th>참조자</th>
                  <th>직급</th>
                  <th>상태</th>
                </tr>
              </thead>
              <tbody id="referersList">
                <!-- 참조자 상태가 여기에 동적으로 추가-->
              </tbody>
            </table>
            <button id="closeBtn" class="btn-custom">확인</button> 
			<button id="recallButton" class="btn-custom" type="button" onclick="recallDocument(event)">회수</button>
          </div>
        </div>
       <div id="approvalModalBackground" class="modal-background-custom"></div>
        <!-- 결재 완료 상태 모달 창 HTML -->
        <div id="CompletedApprovalModal" class="modal-custom" style="display: none;">
		    <div class="modal-content-custom">
		        <span class="close" onclick="closeApprovalModal()">&times;</span>
		        <h3>결재 확인</h3>
		
		        <!-- 문서 정보 및 결재자/참조자 정보 컨테이너 -->
		        <div class="info-container">
		            <!-- 문서 정보 -->
		            <div class="document-info">
		                <table class="header-table">
		                    <colgroup>
		                        <col width="310">
		                        <col width="490">
		                    </colgroup>
		                    <tbody>
		                        <tr>
		                            <td>
		                                <table class="user-info-table">
		                                    <colgroup>
		                                        <col width="90">
		                                        <col width="220">
		                                    </colgroup>
		                                    <tbody>
		                                        <tr>
		                                            <td class="label">기안자</td>
		                                            <td>
		                                                <input type="text" name="memName" id="memName" th:value="${authorization != null && authorization.member != null ? authorization.member.memName : 'Unknown'}" readonly>
		                                            </td>
		                                        </tr>
		                                        <tr>
		                                            <td class="label">소속</td>
		                                            <td>
		                                                <input type="text" name="distributorNo" id="distributorNo" th:value="${authorization != null ? authorization.distributorNo : ''}" readonly>
		                                            </td>
		                                        </tr>
		                                        <tr>
		                                            <td class="label">기안일</td>
		                                            <td>
		                                                <input type="text" name="authorRegDate" id="authorRegDate" th:value="${authorization != null ? #temporals.format(authorization.authorRegDate, 'yyyy-MM-dd') : ''}" readonly>
		                                            </td>
		                                        </tr>
		                                        <tr>
		                                            <td class="label">사원번호</td>
		                                            <td>
		                                                <input type="text" name="empNo" id="empNo" th:value="${authorization != null && authorization.member != null ? authorization.member.empNo : ''}" readonly>
		                                            </td>
		                                        </tr>
		                                    </tbody>
		                                </table>
		                            </td>
		                        </tr>
		                    </tbody>
		                </table>
		            </div>
		
		            <!-- 결재자와 참조자 정보를 표시하는 부분 -->
		            <div class="approval-referer-container">
					    <!-- 첫 번째 결재자 -->
					    <div class="approver-list-container">
					        <div class="list-title">결재자</div>
					        <ul id="approver1List">
					            <!-- 첫 번째 결재자 리스트 -->
					        </ul>
					    </div>
					    <!-- 두 번째 결재자 -->
					    <div class="approver-list-container">
					        <div class="list-title">결재자</div>
					        <ul id="approver2List">
					            <!-- 두 번째 결재자 리스트 -->
					        </ul>
					    </div>
					    <!-- 참조자 -->
					    <div class="referer-list-container">
					        <div class="list-title">참조자</div>
					        <ul id="refererList">
					            <!-- 참조자 리스트 -->
					        </ul>
					    </div>
					</div>
		        </div>
		        <!-- 문서 타입에 따른 필드 설정 -->
		        <div class="field-group" id="leaveFields">
		            <label>휴가 구분</label>
		            <input type="text" id="leaveType" name="leaveType">
		            
		            <label>시작 일정</label>
		            <input type="date" id="startDate" name="startDate">
		            
		            <label>종료 일정</label>
		            <input type="date" id="endDate" name="endDate">
		            
		            <label>신청일 수</label>
		            <input type="number" step="0.1" id="startEndDate" name="startEndDate">
		        </div>
		        <div class="field-group" id="lateFields">
		            <label>지각 사유</label>
		            <input type="text" id="lateType" name="lateType">
		            
		            <label>지각 일시</label>
		            <input type="date" id="lateStartDate" name="startDate">
		        </div>
		        
		        <div class="field-group" id="outsideFields">
		            <label>외근 구분</label>
		            <input type="text" id="outsideType" name="outsideType">
		            
		            <label>외근 시작 시간</label>
		            <input type="time" id="outsideStartDate" name="startDate">
		            
		            <label>외근 종료 시간</label>
		            <input type="time" id="outsideEndDate" name="endDate">
		        </div>
		        
		        <div class="field-group" id="tripFields">
		            <label>출장 구분</label>
		            <input type="text" id="tripType" name="tripType">
		            
		            <label>출발 일정</label>
		            <input type="date" id="tripStartDate" name="startDate">
		            
		            <label>복귀 일정</label>
		            <input type="number" id="tripEndDate" name="endDate">
		        </div>
		        
		        <div class="field-group" id="overtimeFields">
		            <label>야근 구분</label>
		            <input type="text" id="overtimeType" name="overtimeType">
		            
		            <label>야근 시작 시간</label>
		            <input type="time" id="overtimeStartDate" name="startDate">
		            
		            <label>야근 종료 시간</label>
		            <input type="time" id="overtimeEndDate" name="endDate">
		            
		            <label>야근일 수</label>
		            <input type="number" id="overtimeStartEndDate" name="startEndDate">
		        </div>
		
		        <!-- CKEditor 에디터 -->
		        <div>
		            <div id="document-editor" th:utext="${authorization != null ? authorization.authContent : ''}">
		                <textarea class="ckeditor_change"></textarea>
		            </div>
		        </div>
		
		        <!-- File Upload -->
		        <div>
		            <input type="file" name="content" class="file-custom">
		        </div>
		        <br>
				<button id="completedCloseBtn" class="btn-custom" onclick="clearNotification(authorNo)">확인</button>
				<button id="savePdfButton" class="btn-custom">PDF로 저장</button>
		    </div>
		</div>
       <div id="completedModalBackground" class="modal-background-custom"></div>
        <script>
		    const csrfToken = document.querySelector('#csrfToken').value;
		    
		    /**
		     * ## 기능 및 기술 요약
		     * 
		     * ### 기능
		     * - `#CompletedApprovalModal` 모달 내부 특정 콘텐츠를 PDF로 변환하여 사용자가 로컬에 저장할 수 있도록 함
		     * - PDF 생성 및 저장 과정이 완료되면 콘솔에 성공 메시지를 출력하고, 오류가 발생할 경우 콘솔에 오류 메시지를 표시함
		     * 
		     * ### 기술
		     * - `html2pdf` 라이브러리를 사용하여 HTML 요소를 PDF 형식으로 변환
		     * - `html2canvas`는 HTML을 캡처하여 캔버스로 렌더링하고 이를 PDF로 변환
		     * - PDF 저장 옵션을 `jsPDF` 설정으로 용지 단위, 크기 및 방향 등을 지정하여 출력 품질을 높임
		     */
		    // PDF 저장
		    document.getElementById('savePdfButton').addEventListener('click', function () {
			    const element = document.querySelector('#CompletedApprovalModal .modal-content-custom'); // 모달 내부의 특정 컨텐츠만 선택
			
			    // PDF 저장
			    const options = {
			        margin: 0.5,
			        filename: 'document.pdf',
			        image: { type: 'jpeg', quality: 0.98 },
			        html2canvas: { scale: 2 },
			        jsPDF: { unit: 'in', format: 'letter', orientation: 'portrait' }
			    };
			
			    html2pdf().set(options).from(element).save().then(function () {
			        console.log('PDF 저장 완료');
			    }).catch(function (error) {
			        console.error("PDF 변환 오류:", error);
			    });
			});
		    
		    /**
		     * ## 기능 및 기술 요약
		     *
		     * ### 기능
		     * - 문서 유형에 따라 관련된 필드 그룹만 화면에 표시하고, 나머지 필드 그룹은 숨김
		     * - 선택된 문서 유형이 올바르지 않거나 해당 ID의 필드 그룹이 없는 경우 오류 메시지를 출력
		     * 
		     * ### 기술
		     * - `document.querySelectorAll`로 모든 필드 그룹을 선택 후 `forEach` 루프로 숨김 처리
		     * - `switch` 문을 사용하여 문서 유형(`docType`)에 따른 필드 그룹 ID를 결정
		     * - `document.getElementById`를 통해 필드 그룹 요소를 찾아 스타일을 조정
		     * - 오류 처리를 위해 `console.error` 사용하여 잘못된 문서 유형 또는 요소가 없을 경우 메시지 출력
		     */
		 	// 문서 유형에 따른 필드 표시/숨기기 함수
	        function toggleFieldsByDocType(docType) {
	            // 모든 필드 그룹 숨기기
	            document.querySelectorAll('.field-group').forEach(group => group.style.display = 'none');

	            if (!docType) {
	                console.error("올바른 문서 유형이 아닙니다:", docType);
	                return;
	            }

	            // 특정 문서 유형 필드 그룹만 표시
	            let fieldGroupId;
	            switch (docType) {
	                case "off Report":
	                    fieldGroupId = 'leaveFields';
	                    break;
	                case "late Report":
	                    fieldGroupId = 'lateFields';
	                    break;
	                case "trip Report":
	                    fieldGroupId = 'tripFields';
	                    break;
	                case "outside Report":
	                    fieldGroupId = 'outsideFields';
	                    break;
	                case "overtime Report":
	                    fieldGroupId = 'overtimeFields';
	                    break;
	                default:
	                    console.error("알 수 없는 문서 유형입니다: " + docType);
	                    return;
	            }

	            // 필드 그룹이 존재하는지 확인 후 표시
	            const fieldGroup = document.getElementById(fieldGroupId);
	            if (fieldGroup) {
	                fieldGroup.style.display = 'block';
	            } else {
	                console.error("Element with id '" + fieldGroupId + "' not found.");
	            }
	        }
		    

	        /**
	         * ## 기능 및 기술 요약
	         *
	         * ### 기능
	         * - `authorNo`를 기반으로 결재 데이터 로드
	         * - 데이터가 존재할 경우 결재자와 참조자 목록을 HTML에 렌더링하고 모달을 표시
	         * - 데이터가 없거나 로드 중 오류 발생 시 콘솔에 오류 메시지 출력
	         *
	         * ### 기술
	         * - **Promise 기반 비동기 처리**: `fetchApprovalData(authorNo)`를 통해 데이터 비동기 로드 후 `.then()`과 `.catch()`로 후속 처리
	         * - **조건부 렌더링**: 데이터 존재 여부에 따라 모달 표시 여부 결정
	         * - **템플릿 문자열 활용**: `approversHtml`과 `referersHtml`을 템플릿 문자열로 동적 생성하여 HTML 구조에 삽입
	         * - **DOM 조작**: `document.getElementById`로 특정 요소를 선택하고 `innerHTML`을 통해 내용을 업데이트
	         * - **오류 처리**: `console.error`를 통해 오류 메시지를 콘솔에 출력
	         */
	        function openApprovalModal(authorNo) {
	            console.log("Opening approval modal for authorNo:", authorNo);
	            
	            // 먼저 데이터를 로드하고, 성공 시 모달 열기
	            fetchApprovalData(authorNo)
	                .then(data => {
	                    console.log("Data received:", data);

	                    // 데이터가 정상적으로 로드되었으면 모달 열기
	                    if (data && data.length > 0) {
	                        let approversHtml = '';
	                        let referersHtml = '';

	                        data.forEach(approval => {
	                            let statusText = approval.approvalStatus || 'P';  // 기본값을 P로 설정
	                            if (statusText === 'P') {
	                                statusText = '대기중';
	                            } else if (statusText === 'Y') {
	                                statusText = '승인';
	                            } else if (statusText === 'N') {
	                                statusText = '반려';
	                            }

	                            // 결재자 확인 후 처리 (이름과 직급 올바르게 표시)
	                            if (approval.isApprover === 'Y') {
	                                approversHtml += `
	                                    <tr>
	                                        <td>${approval.approverName || '이름 없음'}</td>  <!-- 이름 표시 -->
	                                        <td>${approval.approverRankName || 'N/A'}</td>  <!-- 직급 표시 -->
	                                        <td>${statusText}</td>
	                                    </tr>`;
	                            }

	                            // 참조자 확인 후 처리 (이름과 직급 올바르게 표시)
	                            if (approval.isReferer === 'Y') {
	                                referersHtml += `
	                                    <tr>
	                                        <td>${approval.refererName || '이름 없음'}</td>  <!-- 이름 표시 -->
	                                        <td>${approval.refererRankName || 'N/A'}</td>  <!-- 직급 표시 -->
	                                        <td>${statusText}</td>
	                                    </tr>`;
	                            }
	                        });

	                        document.getElementById('approversList').innerHTML = approversHtml;
	                        document.getElementById('referersList').innerHTML = referersHtml;

	                        // 추가: authorNo를 hidden input 필드에 설정
	                        document.getElementById('authorNo').value = authorNo;

	                        // 모달 표시
	                        document.getElementById('approvalModal').style.display = 'block';
	                        document.getElementById('approvalModalBackground').style.display = 'block';
	                    } else {
	                        console.error("No approval data found for authorNo:", authorNo);
	                    }
	                })
	                .catch(error => {
	                    console.error("Error fetching approval data:", error);
	                });
	        }

	        /**
	         * ## 기능 및 기술 요약
	         *
	         * ### 기능
	         * - `authorNo`를 기반으로 서버에 승인 중인 문서 데이터를 요청
	         * - 서버에서 응답받은 데이터를 JSON 형식으로 파싱하여 반환
	         *
	         * ### 기술
	         * - **Fetch API**: HTTP 요청을 서버에 비동기로 전송. `fetch`는 Promise 기반으로, 후속 처리를 `.then()`과 `.catch()`에서 수행
	         * - **CSRF 보안**: CSRF 보호를 위해 `X-CSRF-TOKEN` 헤더에 토큰 값을 추가하여 요청 전송
	         * - **응답 상태 확인**: `response.ok`로 서버 응답의 상태 코드가 성공적인지 확인. 오류 발생 시 `Error` 객체를 생성하여 `.catch()`로 전달
	         * - **JSON 응답 파싱**: 응답을 JSON 형식으로 변환 (`response.json()`), 이후 비동기적으로 데이터가 제공됨
	         */
	        // 승인중인 문서 데이터 로드 함수
	        function fetchApprovalData(authorNo) {
	            return fetch(`/approval/${authorNo}`, {
	                headers: {
	                    'X-CSRF-TOKEN': csrfToken
	                }
	            })
	            .then(response => {
	                if (!response.ok) {
	                    throw new Error('Network response was not ok');
	                }
	                return response.json();
	            });
	        }

	         /**
	          * ## 기능 및 기술 요약
	          *
	          * ### 기능
	          * - `authorNo`를 이용해 특정 완료된 문서의 데이터를 서버로부터 비동기적으로 가져온 후 모달에 표시
	          * - 문서 내용과 사용자 정보를 동적으로 할당하여 화면에 표시
	          * - 문서 유형에 따라 필요한 필드를 선택적으로 표시 및 숨김 처리

	          * ### 기술
	          * - **Fetch API**: HTTP 요청을 통해 서버에 데이터를 요청하고, 비동기적으로 데이터를 받아옴. Promise 기반으로 처리하여 `.then()`으로 성공 시 데이터를 처리하고, `.catch()`로 오류를 관리
	          * - **CSRF 보안**: `X-CSRF-TOKEN` 헤더에 CSRF 토큰을 추가하여 서버 요청의 보안을 강화
	          * - **데이터 바인딩**: JSON 형식으로 응답받은 데이터를 DOM 요소에 할당하여 필요한 필드에 값 표시
	          * - **조건부 필드 표시/숨기기**: 문서 유형에 따라 DOM 요소의 표시를 동적으로 변경 (`toggleFieldsByDocType` 함수 활용)
	          * - **결재자 및 참조자 정보 업데이트**: 문서의 결재자와 참조자 정보를 테이블에 반영 (`updateApproverTable` 함수 호출)
	          * - **모달창 표시**: 조건에 따라 특정 모달 요소를 선택적으로 표시하거나 숨김 처리하여 사용자 인터페이스를 구성
	          */
	        // 완료 문서용 모달 창 열기 함수 (데이터 로드 후 모달 열기)
	        function openCompletedApprovalModal(authorNo) {
	            console.log("Opening completed approval modal for authorNo:", authorNo);
	            
	            // 먼저 데이터를 로드하고, 성공 시 모달 열기
	            fetchCompletedApprovalData(authorNo)
	                .then(data => {
	                    console.log("Fetched data:", data);  // 전체 데이터를 출력하여 확인
	                    console.log("Fetched approvers data:", data.approvers);
                        console.log("Fetched referers data:", data.referers);
						
	                    // 데이터가 제대로 들어오는지 확인 후 필드에 적용
	                    if (data && data.authorNo) {
	                        document.getElementById('authorNo').value = data.authorNo;

	                        // CKEditor 내용 설정
	                        if (document.querySelector('.ckeditor_change')) {
	                            document.querySelector('.ckeditor_change').value = data.authContent || '';
	                        }

	                        // 추가된 정보 바인딩
	                        if (document.querySelector('[name="memName"]')) {
	                            document.querySelector('[name="memName"]').value = data.memName || '';
	                        }
	                        if (document.querySelector('[name="empNo"]')) {
	                            document.querySelector('[name="empNo"]').value = data.empNo || '';
	                        }
	                        if (document.querySelector('[name="distributorNo"]')) {
	                            let distributorNo = data.distributorNo;
	                            let distributorName = distributorMap[distributorNo] || distributorNo;
	                            document.querySelector('[name="distributorNo"]').value = distributorName;
	                        }
	                        if (document.querySelector('[name="authorRegDate"]')) {
	                            document.querySelector('[name="authorRegDate"]').value = data.authorRegDate ? new Date(data.authorRegDate).toISOString().split('T')[0] : '';
	                        }

	                        // 문서 유형에 따라 필드 표시/숨기기
	                        toggleFieldsByDocType(data.doctype);

	                        // 필드 요소가 존재할 때만 값을 설정
	                        switch (data.doctype) {
	                            case "off Report":
	                                if (document.querySelector('[name="leaveType"]')) {
	                                    document.querySelector('[name="leaveType"]').value = data.leaveType || '';
	                                }
	                                if (document.querySelector('[name="startDate"]')) {
	                                    document.querySelector('[name="startDate"]').value = data.startDate || '';
	                                }
	                                if (document.querySelector('[name="endDate"]')) {
	                                    document.querySelector('[name="endDate"]').value = data.endDate || '';
	                                }
	                                if (document.querySelector('[name="startEndDate"]')) {
	                                    document.querySelector('[name="startEndDate"]').value = data.startEndDate || '';
	                                }
	                                break;
	                            case "late Report":
	                                if (document.querySelector('[name="lateType"]')) {
	                                    document.querySelector('[name="lateType"]').value = data.lateType || '';
	                                }
	                                if (document.querySelector('[name="startDate"]')) {
	                                    document.querySelector('[name="startDate"]').value = data.startDate || '';
	                                }
	                                break;
	                            case "trip Report":
	                                if (document.querySelector('[name="tripType"]')) {
	                                    document.querySelector('[name="tripType"]').value = data.tripType || '';
	                                }
	                                if (document.querySelector('[name="startDate"]')) {
	                                    document.querySelector('[name="startDate"]').value = data.startDate || '';
	                                }
	                                if (document.querySelector('[name="endDate"]')) {
	                                    document.querySelector('[name="endDate"]').value = data.endDate || '';
	                                }
	                                break;
	                            case "outside Report":
	                                if (document.querySelector('[name="outsideType"]')) {
	                                    document.querySelector('[name="outsideType"]').value = data.outsideType || '';
	                                }
	                                if (document.querySelector('[name="startDate"]')) {
	                                    document.querySelector('[name="startDate"]').value = data.startDate || '';
	                                }
	                                if (document.querySelector('[name="endDate"]')) {
	                                    document.querySelector('[name="endDate"]').value = data.endDate || '';
	                                }
	                                break;
	                            case "overtime Report":
	                                if (document.querySelector('[name="overtimeType"]')) {
	                                    document.querySelector('[name="overtimeType"]').value = data.overtimeType || '';
	                                }
	                                if (document.querySelector('[name="startDate"]')) {
	                                    document.querySelector('[name="startDate"]').value = data.startDate || '';
	                                }
	                                if (document.querySelector('[name="endDate"]')) {
	                                    document.querySelector('[name="endDate"]').value = data.endDate || '';
	                                }
	                                if (document.querySelector('[name="startEndDate"]')) {
	                                    document.querySelector('[name="startEndDate"]').value = data.startEndDate || '';
	                                }
	                                break;
	                            default:
	                                console.error("알 수 없는 문서 유형입니다: " + data.doctype);
	                                break;
	                        }

	                        // 결재자 및 참조자 정보 업데이트 (signature 포함)
	                        updateApproverTable(data.approvers, data.referers);
	                        
	                        
	                        // 모달창을 표시
	                        const completedModal = document.getElementById('CompletedApprovalModal');
	                        const completedModalBackground = document.getElementById('completedModalBackground');
	                        if (completedModal && completedModalBackground) {
	                            completedModal.style.display = 'block';
	                            completedModalBackground.style.display = 'block';
	                        } else {
	                            console.error("CompletedApprovalModal 또는 completedModalBackground 요소가 존재하지 않습니다.");
	                        }
	                    } else {
	                        console.error("No data found for completed document with authorNo:", authorNo);
	                    }
	                })
	                .catch(error => {
	                    console.error('Error fetching document:', error);
	                    alert('문서를 가져오는 중 오류가 발생했습니다.');
	                });
	        }

	          /**
	           * ## 기능 및 기술 요약
	           *
	           * ### 기능
	           * - 서버로부터 `authorNo`를 기반으로 특정 완료 문서의 데이터를 비동기적으로 로드
	           * - 응답된 데이터를 JSON 형식으로 변환하여 이후 함수에서 활용할 수 있도록 반환

	           * ### 기술
	           * - **Fetch API**: 서버와 비동기적으로 통신하여 데이터를 가져옴. `fetch` 메서드를 사용하여 HTTP 요청을 전송하고 `.then()` 체이닝을 통해 성공 시 JSON 응답을 반환
	           * - **CSRF 보안**: 요청 헤더에 `X-CSRF-TOKEN`을 추가하여 CSRF 공격 방지
	           * - **오류 처리**: 응답 상태가 성공적이지 않은 경우 `Error` 객체를 생성하고 `throw`하여 오류 처리, 이후 `.catch()`에서 이를 핸들링 가능
	           * - **JSON 변환**: `response.json()`을 호출해 JSON 형식으로 데이터를 변환하여 Promise로 반환, 이후 데이터를 사용할 수 있도록 보장
	           */  
	        // 완료 문서용 데이터 로드 함수
	        function fetchCompletedApprovalData(authorNo) {
	            return fetch(`/api/authorization/${authorNo}`, {
	                headers: {
	                    'X-CSRF-TOKEN': csrfToken
	                }
	            })
	            .then(response => {
	                if (!response.ok) {  // 응답이 성공적이지 않은 경우 오류 던지기
	                    throw new Error(`HTTP error! status: ${response.status}`);
	                }
	                return response.json();
	            });
	        }
			
	           /**
	            * ## 기능 및 기술 요약
	            *
	            * ### 기능
	            * - 결재자와 참조자 정보를 화면에 업데이트
	            * - 각 결재자 및 참조자 정보를 받아 리스트에 해당 정보를 표시
	            * - 결재자/참조자 서명이 있을 경우 이미지로 표시하고, 없을 경우 기본 텍스트(`서명 없음`)로 대체

	            * ### 기술
	            * - **DOM 조작**: `document.getElementById()`와 `innerHTML`을 사용하여 각 결재자 및 참조자 정보를 동적으로 업데이트
	            * - **조건부 데이터 바인딩**: 결재자, 참조자 정보가 존재할 때만 정보를 표시하며, 없을 경우 `결재자 없음` 또는 `참조자 없음`을 기본값으로 사용
	            * - **에러 핸들링**: `try-catch` 구문을 통해 데이터 처리 과정에서 발생할 수 있는 잠재적 오류를 포착하고 로그로 표시
	            * - **서명 표시 로직**: `Base64` 서명 데이터를 이미지 태그(`<img>`)로 변환하여 서명을 표시하거나, 데이터가 없을 경우 `서명 없음` 텍스트로 대체
	            * - **로그 출력**: `console.log`와 `console.warn`을 사용하여 결재자/참조자 정보와 서명 데이터를 콘솔에 출력, 문제 발생 시 디버깅에 도움
	            */
	     	// 결재자와 참조자 정보를 업데이트하는 함수
	        function updateApproverTable(approvers, referers) {
	            try {
	                // 첫 번째 결재자 리스트 초기화
	                const approver1List = document.getElementById('approver1List');
	                approver1List.innerHTML = ''; // 기존 내용을 초기화

	                // 첫 번째 결재자 정보 업데이트
	                if (approvers.length > 0 && approvers[0]) {
	                    const approver1 = approvers[0];
	                    console.log("첫 번째 결재자 데이터:", approver1); // 데이터 확인용 로그

	                    // Base64 문자열과 길이 확인
	                    console.log("Approver 1 Signature Data:", approver1.approverSignature);
	                    console.log("Approver 1 Signature Length:", approver1.approverSignature ? approver1.approverSignature.length : 'null');

	                    let signatureHtml = approver1.approverSignature
		                    ? `<img src="${approver1.approverSignature.trim()}" alt="서명" style="width: 50px; height: 50px;">`
		                    : '서명 없음'; // 서명이 없을 경우


	                    const listItem = document.createElement('li'); // tr 태그 생성
	                    listItem.innerHTML = `
	                        <span>${approver1.memberName || "결재자 이름 없음"}</span>
	                        <span>${signatureHtml}</span>
	                    `;
	                    approver1List.appendChild(listItem); // tr 요소를 첫 번째 결재자 리스트에 추가
	                } else {
	                    console.warn("첫 번째 결재자 없음");
	                    const emptyItem = document.createElement('li');
	                    emptyItem.innerHTML = `<span colspan="2">결재자 없음</span>`;
	                    approver1List.appendChild(emptyItem);
	                }

	                // 두 번째 결재자 리스트 초기화
	                const approver2List = document.getElementById('approver2List');
	                approver2List.innerHTML = ''; // 기존 내용을 초기화

	                // 두 번째 결재자 정보 업데이트
	                if (approvers.length > 1 && approvers[1]) {
	                    const approver2 = approvers[1];
	                    console.log("두 번째 결재자 데이터:", approver2); // 데이터 확인용 로그

	                    // Base64 문자열과 길이 확인
	                    console.log("Approver 2 Signature Data:", approver2.approverSignature);
	                    console.log("Approver 2 Signature Length:", approver2.approverSignature ? approver2.approverSignature.length : 'null');

	                    let signatureHtml = approver2.approverSignature
		                    ? `<img src="${approver1.approverSignature.trim()}" alt="서명" style="width: 50px; height: 50px;">`
		                    : '서명 없음'; // 서명이 없을 경우


	                    const listItem = document.createElement('li'); // tr 태그 생성
	                    listItem.innerHTML = `
	                        <span>${approver2.memberName || "결재자 이름 없음"}</span>
	                        <span>${signatureHtml}</span>
	                    `;
	                    approver2List.appendChild(listItem); // tr 요소를 두 번째 결재자 리스트에 추가
	                } else {
	                    console.warn("두 번째 결재자 없음");
	                    const emptyItem = document.createElement('li');
	                    emptyItem.innerHTML = `<span colspan="2">결재자 없음</span>`;
	                    approver2List.appendChild(emptyItem);
	                }

	                // 참조자 리스트 초기화
	                const refererList = document.getElementById('refererList');
	                refererList.innerHTML = ''; // 기존 내용을 초기화

	                // 참조자 정보 업데이트
	                if (referers.length > 0 && referers[0]) {
	                    const referer = referers[0];
	                    console.log("참조자 데이터:", referer); // 데이터 확인용 로그

	                    // Base64 문자열과 길이 확인
	                    console.log("Referer Signature Data:", referer.refererSignature);
	                    console.log("Referer Signature Length:", referer.refererSignature ? referer.refererSignature.length : 'null');

	                    let signatureHtml = referer.refererSignature
	                    	? `<img src="${referer.refererSignature.trim()}" alt="서명" style="width: 50px; height: 50px;">`
	                    	: '서명 없음'; // 서명이 없을 경우


	                    const listItem = document.createElement('li'); // tr 태그 생성
	                    listItem.innerHTML = `
	                        <span>${referer.memberName || "참조자 이름 없음"}</span>
	                        <span>${signatureHtml}</span>
	                    `;
	                    refererList.appendChild(listItem); // tr 요소를 참조자 리스트에 추가
	                } else {
	                    console.warn("참조자 없음");
	                    const emptyItem = document.createElement('li');
	                    emptyItem.innerHTML = `<span colspan="2">참조자 없음</span>`;
	                    refererList.appendChild(emptyItem);
	                }
	            } catch (error) {
	                console.error("오류 발생:", error);
	            }
	        }

			// ApprovalModal과 배경을 동시에 열기
			function openApprovalModalWithBackground() {
			    console.log("Open ApprovalModal Function Called");
			    const approvalModal = document.getElementById('approvalModal');
			    const approvalModalBackground = document.getElementById('approvalModalBackground');
			    if (approvalModal && approvalModalBackground) {
			        approvalModal.style.display = 'block';
			        approvalModalBackground.style.display = 'block';
			    } else {
			        console.error("approvalModal 또는 approvalModalBackground 요소가 존재하지 않습니다.");
			    }
			}

			// ApprovalModal과 배경을 동시에 닫기
			function closeApprovalModalWithBackground() {
			    console.log("Close ApprovalModal Function Called");
			    const approvalModal = document.getElementById('approvalModal');
			    const approvalModalBackground = document.getElementById('approvalModalBackground');
			    if (approvalModal && approvalModalBackground) {
			        approvalModal.style.display = 'none';
			        approvalModalBackground.style.display = 'none';
			    } else {
			        console.error("approvalModal 또는 approvalModalBackground 요소가 존재하지 않습니다.");
			    }
			}

		    
			
			function openModal() {
		        console.log("Open Modal Function Called");
		        // 모달 창 열기
		        const modal = document.getElementById('documentModal');
		        const modalBackground = document.getElementById('modalBackground');
		        if (modal && modalBackground) {
		            modal.style.display = 'block';
		            modalBackground.style.display = 'block';
		        } else {
		            console.error("documentModal 또는 modalBackground ID를 가진 요소가 존재하지 않습니다.");
		        }
		    }

		    function closeModal() {
		        console.log("Close Modal Function Called");
		        // 모달 창 닫기
		        const modal = document.getElementById('documentModal');
		        const modalBackground = document.getElementById('modalBackground');
		        if (modal && modalBackground) {
		            modal.style.display = 'none';
		            modalBackground.style.display = 'none';
		        }
		    }
		    

		    
		
		 	// 모달 닫기 기능 추가
		    document.querySelector('.close').addEventListener('click', function() {
		        document.getElementById('approvalModal').style.display = 'none';
		        document.getElementById('approvalModalBackground').style.display = 'none'; // 배경도 닫기
		    });

		    // 닫기 버튼이 여러 개 있을 경우
		    document.querySelectorAll('.close').forEach(closeBtn => {
		        closeBtn.addEventListener('click', function() {
		            document.getElementById('approvalModal').style.display = 'none';
		            document.getElementById('approvalModalBackground').style.display = 'none'; // 배경도 닫기
		        });
		    });

		    // 확인 버튼 클릭 시 모달 닫기 기능 추가
		    document.getElementById('closeBtn').addEventListener('click', function() {
		        document.getElementById('approvalModal').style.display = 'none';
		        document.getElementById('approvalModalBackground').style.display = 'none'; // 배경도 닫기
		    });

		    // 모달 바깥쪽 클릭 시 닫기
		    window.addEventListener('click', function(event) {
		        const modal = document.getElementById('approvalModal');
		        const modalBackground = document.getElementById('approvalModalBackground');
		        if (event.target == modalBackground) {
		            modal.style.display = 'none';
		            modalBackground.style.display = 'none'; // 배경도 닫기
		        }
		    });

		    
		 	// CompletedApprovalModal 모달 닫기 기능 추가
		    document.querySelectorAll('.close').forEach(closeBtn => {
		        closeBtn.addEventListener('click', function() {
		            document.getElementById('CompletedApprovalModal').style.display = 'none';
		            document.getElementById('completedModalBackground').style.display = 'none';
		        });
		    });

			 // CompletedApprovalModal의 확인 버튼 ID를 확인하고 별도의 고유한 ID로 사용
		    document.addEventListener('DOMContentLoaded', function() {
		        const completedCloseBtn = document.getElementById('completedCloseBtn'); // 고유한 ID 확인
		        if (completedCloseBtn) {
		            completedCloseBtn.addEventListener('click', function() {
		                document.getElementById('CompletedApprovalModal').style.display = 'none';
		                document.getElementById('completedModalBackground').style.display = 'none';
		            });
		        } else {
		            console.error("Element with id 'completedCloseBtn' not found.");
		        }
		    });

		    // CompletedApprovalModal 모달 바깥쪽 클릭 시 닫기
		    window.addEventListener('click', function(event) {
		        const completedModal = document.getElementById('CompletedApprovalModal');
		        const completedModalBackground = document.getElementById('completedModalBackground');
		        if (event.target === completedModalBackground) {
		            completedModal.style.display = 'none';
		            completedModalBackground.style.display = 'none';
		        }
		    });


		    // 모달이 없는 경우 확인
		    window.addEventListener('DOMContentLoaded', () => {
		        const modal = document.getElementById('approvalModal');
		        const closeModalButton = document.querySelector('.close');
		        const closeBtn = document.getElementById('closeBtn');

		        if (!modal) {
		            console.error("approvalModal ID를 가진 모달 요소가 존재하지 않습니다.");
		        }

		        if (!closeModalButton) {
		            console.error("모달 닫기 버튼 (.close 클래스)을 찾을 수 없습니다.");
		        }

		        if (!closeBtn) {
		            console.error("모달 확인 버튼 (#closeBtn)을 찾을 수 없습니다.");
		        }
		    });

		    /**
		     * ## 기능 및 기술 요약
		     *
		     * ### 기능
		     * - 사용자가 문서 유형을 선택할 때 해당 문서 작성 페이지로 이동
		     * - 사용자가 이동을 확인하도록 확인창을 표시

		     * ### 기술
		     * - **사용자 확인**: `confirm()` 함수를 통해 사용자가 선택한 문서를 작성할지 확인 메시지를 표시하고, 확인 시에만 URL로 이동
		     * - **URL 이동**: 사용자가 확인창에서 '확인'을 누르면 `window.location.href`를 통해 지정된 URL로 페이지를 이동
		     */
		    // 문서 선택 시 URL로 이동
		    function selectDocument(documentType, url) {
		        if (confirm(documentType + ' 문서를 작성하시겠습니까?')) {
		            window.location.href = url;
		        }
		    }
		
		    /**
		     * ## 기능 및 기술 요약
		     *
		     * ### 기능
		     * - 서버로부터 완료된 문서 목록을 가져오고 화면에 업데이트
		     * - 네트워크 오류나 데이터 수신 실패 시 콘솔에 오류 메시지 표시

		     * ### 기술
		     * - **API 요청**: `fetch()` 함수를 사용하여 서버의 `/authorization/completed` 엔드포인트에서 완료된 문서 데이터를 요청
		     * - **데이터 형식**: 응답 데이터를 JSON 형식으로 파싱하여 JavaScript 객체로 변환
		     * - **오류 처리**: 응답 상태가 실패(`!response.ok`)일 경우 오류를 발생시키고, `catch`에서 오류를 로그
		     * - **화면 업데이트**: 성공적으로 데이터를 가져오면 `updateCompletedDocumentList()` 함수를 호출하여 가져온 데이터로 화면 업데이트
		     */
		    // 완료된 문서 가져오는 함수
		    function fetchCompletedDocuments() {
		        console.log('Fetching completed documents...'); // 함수 호출 확인
		        fetch('/authorization/completed') // 완료된 문서 가져오는 API 엔드포인트
		            .then(response => {
		                console.log('Response received:', response); // 응답 객체 확인
		                if (!response.ok) {
		                    throw new Error('Network response was not ok');
		                }
		                return response.json();
		            })
		            .then(data => {
		                console.log('Completed documents fetched:', data); // documents 배열 구조 확인
		                updateCompletedDocumentList(data); // 가져온 데이터를 이용하여 화면 업데이트
		            })
		            .catch(error => {
		                console.error('Error fetching completed documents:', error);
		            });
		    }
		
		    /**
		     * ## 기능 및 기술 요약
		     *
		     * ### 기능
		     * - 서버에서 전달된 완료된 문서 목록 데이터를 받아 테이블에 표시
		     * - 문서 상태에 따라 상태별로 표시하고, 날짜를 한국 날짜 형식으로 변환하여 표시
		     * - 문서가 없을 경우 ‘완료된 문서가 없습니다.’라는 메시지 표시

		     * ### 기술
		     * - **DOM 조작**: `document.getElementById()` 및 `innerHTML`을 사용해 완료된 문서 목록을 업데이트하고, 새로운 문서를 리스트에 추가
		     * - **날짜 형식 변환**: JavaScript `Date` 객체의 `toLocaleDateString`을 사용해 한국어 날짜 형식으로 변환 후 표시
		     * - **조건부 상태 표시**: `authorStatus`에 따라 승인(Y), 반려(N), 확인(C) 등의 상태를 텍스트로 변환하여 테이블에 표시
		     * - **데이터 매핑**: `docTypeMap` 객체를 이용해 문서 유형을 한글로 매핑하고, 미매핑 시 원본 `doctype` 값을 그대로 표시
		     */

		 	// 완료된 문서 목록 업데이트
		    function updateCompletedDocumentList(documents) {
		        const completeList = document.getElementById('completeList');
		        completeList.innerHTML = ''; // 기존 목록 초기화

		        if (!documents || documents.length === 0) {
		            completeList.innerHTML = '<tr><td colspan="4">완료된 문서가 없습니다.</td></tr>';
		            return;
		        }

		        documents.forEach(doc => {
		            if (doc.authorStatus === 'Y' || doc.authorStatus === 'N' || doc.authorStatus === 'C') {  // C 상태 추가
		                const row = document.createElement('tr');
		                
		                let formattedDate = '';
		                if (doc.authorRegDate) {
		                    const date = new Date(doc.authorRegDate);
		                    formattedDate = date.toLocaleDateString('ko-KR', {
		                        year: 'numeric',
		                        month: '2-digit',
		                        day: '2-digit'
		                    }).replace(/ /g, ''); 
		                    
		                    formattedDate = formattedDate.endsWith('.') ? formattedDate.slice(0, -1) : formattedDate;
		                }

		                row.innerHTML = `
		                    <td>${formattedDate}</td>
		                    <td>${docTypeMap[doc.doctype] || doc.doctype}</td>
		                    <td><a href="/authorization/${doc.authorNo}">${doc.authTitle != null ? doc.authTitle : '제목 없음'}</a></td>
		                    <td>${doc.authorStatus === 'Y' ? '승인' : (doc.authorStatus === 'N' ? '반려' : (doc.authorStatus === 'C' ? '확인' : 'Unknown'))}</td>
		                `;
		                completeList.appendChild(row);

		            }
		        });
		    }

		     /**
		      * ## 기능 및 기술 요약
		      *
		      * ### 기능
		      * - 서버에서 기안 중인 문서 목록을 가져와 화면에 표시
		      * - 성공적으로 데이터를 가져오면 `updateDraftDocumentList` 함수를 호출하여 화면에 목록을 업데이트
		      * - 네트워크 응답이 실패하면 에러를 콘솔에 출력

		      * ### 기술
		      * - **API 호출**: `fetch()`를 사용해 `/authorization/drafts` API 엔드포인트로 기안 중인 문서 목록 요청
		      * - **응답 처리**: 서버 응답이 정상적이면 `response.json()`을 통해 데이터를 받아옴
		      * - **에러 처리**: 응답이 실패하면 `throw`를 사용하여 에러를 던지고, `catch` 블록에서 처리
		      * - **데이터 디버깅**: `console.log()`를 사용하여 함수 호출 및 응답 데이터를 디버깅
		      */

		    // 기안 진행 목록 가져오기 
		    function fetchDraftDocuments() {
		        console.log('Fetching draft documents...'); // 함수 호출 확인
		        fetch('/authorization/drafts') // 기안 진행 중 문서만 가져오는 API 엔드포인트
		            .then(response => {
		                console.log('Response received:', response); // 응답 객체 확인
		                if (!response.ok) {
		                    throw new Error('Network response was not ok');
		                }
		                return response.json();
		            })
		            .then(data => {
		                console.log('Draft documents fetched:', data);
		                updateDraftDocumentList(data); // 기안 진행 목록 업데이트
		            })
		            .catch(error => {
		                console.error('Error fetching draft documents:', error);
		            });
		    }
		
		      /**
		       * ## 기능 및 기술 요약
		       *
		       * ### 기능
		       * - 기안 진행 중인 문서 목록을 화면에 업데이트
		       * - `authorStatus`가 'P'인 문서만 표시 (대기 중인 문서)
		       * - 기안 진행 중인 문서가 없으면 "기안 진행 중인 문서가 없습니다." 메시지 표시
		       * - 각 문서에 대해 기안 등록일, 문서 유형, 제목, 상태(대기 중) 정보 표시

		       * ### 기술
		       * - **DOM 조작**: `document.getElementById()`를 사용하여 기안 진행 목록에 해당하는 HTML 요소를 선택
		       * - **HTML 생성**: `createElement()`를 사용하여 `tr` 요소를 동적으로 생성
		       * - **목록 초기화**: `innerHTML = ''`을 사용하여 이전 데이터를 지우고 새로고침
		       * - **조건문 사용**: `if (doc.authorStatus === 'P')`로 대기 중인 문서만 표시
		       * - **디버깅**: `console.log()` 없이 기본 로직만 처리
		       */

		 	// 기안 진행 목록 업데이트
		    function updateDraftDocumentList(documents) {
		        const resultList = document.getElementById('resultList'); // 기안 진행 목록의 HTML ID
		        draftList.innerHTML = ''; // 기존 목록 초기화

		        if (!documents || documents.length === 0) {
		            resultList.innerHTML = '<tr><td colspan="4">기안 진행 중인 문서가 없습니다.</td></tr>';
		            return;
		        }

		        documents.forEach(doc => {
		            // 대기 중(P) 상태인 문서만 표시
		            if (doc.authorStatus === 'P') { // 'P' 상태 확인
		                const row = document.createElement('tr');
		                row.innerHTML = `
		                    <td>${doc.authorRegDate != null ? doc.authorRegDate : ''}</td>
		                    <td>${docTypeMap[doc.doctype] || doc.doctype}</td>
		                    <td><a href="/authorization/${doc.authorNo}">${doc.authTitle != null ? doc.authTitle : '제목 없음'}</a></td>
		                    <td>대기 중</td>
		                `;
		                resultList.appendChild(row);
		            }
		        });
		    }
		 	
		       /**
		        * ## 기능 및 기술 요약
		        *
		        * ### 기능
		        * - 완료된 문서 데이터를 API에서 가져와서 처리
		        * - `fetch()` 메서드를 사용하여 `/authorization/completed` API 엔드포인트에서 완료된 문서 목록을 가져옴
		        * - 응답을 JSON으로 변환 후 `updateCompletedDocumentList()` 함수에 데이터를 전달하여 화면을 업데이트
		        * - 오류 발생 시 콘솔에 에러 메시지를 출력하고, 사용자에게 오류 정보를 알림

		        * ### 기술
		        * - **API 호출**: `fetch()` 메서드를 사용하여 RESTful API에서 데이터를 가져옴
		        * - **응답 처리**: `response.json()`을 사용하여 응답을 JSON 형식으로 변환
		        * - **에러 처리**: `catch()` 메서드를 사용하여 네트워크 오류나 응답 오류를 처리
		        * - **디버깅**: `console.log()`로 데이터 상태를 출력하여 디버깅 및 확인
		        */

		 	// 완료 문서 데이터 로딩
		    function fetchCompletedDocuments() {
		        console.log('Fetching completed documents...'); // 함수 호출 확인
		        fetch('/authorization/completed') // 완료된 문서 가져오는 API 엔드포인트
		            .then(response => {
		                console.log('Response received:', response); // 응답 객체 확인
		                if (!response.ok) {
		                    throw new Error('Network response was not ok');
		                }
		                return response.json();
		            })
		            .then(data => {
		                console.log('Completed documents fetched:', data); // 데이터 확인
		                updateCompletedDocumentList(data); // 완료 문서 목록 업데이트
		            })
		            .catch(error => {
		                console.error('Error fetching completed documents:', error);
		            });
		    }
		 	
		       /**
		        * ## 기능 및 기술 요약
		        *
		        * ### 기능
		        * - 문서 유형을 표시하기 위한 매핑 객체
		        * - 각 문서 유형에 대해 사용자 친화적인 이름을 매핑하여 보여줌
		        *
		        * ### 기술
		        * - **객체 구조**: `docTypeMap` 객체를 사용하여 문서 유형 코드(예: `"trip Report"`)를 해당하는 한글 문서명(예: `"해외 출장 신청서"`)으로 매핑
		        * - **목적**: 문서 유형 코드 대신 사용자에게 이해하기 쉬운 한글 제목을 제공
		        */
		    const docTypeMap = {
		        "trip Report": "해외 출장 신청서",
		        "late Report": "지각 사유서",
		        "off Report": "연차 보고서",
		        "overtime Report": "야근 신청서",
		        "outside Report": "외근 신청서"
		    };
		
		    /**
		     * ## 기능 및 기술 요약
		     *
		     * ### 기능
		     * - 문서 유형을 한글로 변환하여 표시하는 함수
		     * - 테이블 내 문서 유형 코드(`docType`)를 `docTypeMap` 객체를 이용해 한글로 변환
		     * - 변환된 값을 해당 테이블 셀에 업데이트
		     *
		     * ### 기술
		     * - **문서 유형 변환**: `querySelectorAll`을 이용해 문서 유형을 포함하는 테이블 셀을 선택
		     * - **매핑 처리**: 선택된 문서 유형 코드 값을 `docTypeMap` 객체를 사용해 한글로 변환하고, 변환된 값을 테이블 셀에 업데이트
		     */
		    // 문서양식을 한글로 표시하기 위한 함수
		    function displayDocTypeInKorean() {
		        // 테이블에서 두 번째 열의 <td> 요소들을 선택합니다.
		        let docTypeElements = document.querySelectorAll('#resultList td:nth-child(2), #completeList td:nth-child(2)');
		        docTypeElements.forEach((element) => {
		            let docTypeValue = element.innerText.trim();
		            // 한글로 변환된 값을 <td>에 넣습니다.
		            element.innerText = docTypeMap[docTypeValue] || docTypeValue;
		        });
		    }
		
		    window.onload = function() {
		        displayDocTypeInKorean();  // 기존 문서 양식 표시 함수
		        fetchDraftDocuments(); // 기안 진행 목록 로드
		        fetchCompletedDocuments();  // 완료 문서 가져오는 함수 추가 호출
		    };
		   
		 // distributorNo와 distributorName의 매핑 객체
	        const distributorMap = {
	            1: '서울 강남지점',
	            2: '서울 강북지점',
	            3: '서울 서초지점',
	            4: '서울 송파지점',
	            5: '서울 영등포지점',
	            6: '경기 수원지점',
	            7: '경기 성남지점',
	            8: '경기 고양지점',
	            9: '경기 용인지점',
	            10: '경기 안양지점',
	            11: '인천 부평지점',
	            12: '인천 남동지점',
	            13: '인천 서구지점',
	            14: '인천 연수지점',
	            15: '인천 중구지점',
	            16: '부산 해운대지점',
	            17: '부산 사상지점',
	            18: '부산 남구지점',
	            19: '부산 동래지점',
	            20: '부산 북구지점',
	            21: '대구 중구지점',
	            22: '대구 동구지점',
	            23: '대구 서구지점',
	            24: '대구 남구지점',
	            25: '대구 북구지점',
	            26: '광주 서구지점',
	            27: '광주 북구지점',
	            28: '광주 동구지점',
	            29: '광주 남구지점',
	            30: '광주 광산지점',
	            31: '대전 중구지점',
	            32: '대전 동구지점',
	            33: '대전 서구지점',
	            34: '대전 유성지점',
	            35: '대전 대덕지점',
	            36: '울산 남구지점',
	            37: '울산 동구지점',
	            38: '울산 북구지점',
	            39: '울산 중구지점',
	            40: '울산 울주지점',
	            41: '제주도 제주지점'
	        };

	        /**
	         * ## 기능 및 기술 요약
	         *
	         * ### 기능
	         * - `distributorNo` 값을 이용해 해당하는 `distributorName`을 변환하여 표시하는 함수
	         * - `distributorNo`가 존재하면, 이를 `distributorMap`을 통해 `distributorName`으로 변환
	         * - 변환된 값을 입력 필드에 업데이트
	         *
	         * ### 기술
	         * - **분배자 이름 변환**: `distributorNo` 값을 가져와 `distributorMap`을 이용해 변환
	         * - **값 업데이트**: 변환된 `distributorName`을 해당 `input` 요소에 설정
	         */
	        function displayDistributorName() {
	            // distributorNo를 선택하여 요소 가져오기
	            let distributorElement = document.getElementById('distributorNo');
	            if (distributorElement) {
	                // distributorNo 값 가져오기
	                let distributorNo = distributorElement.value.trim();
	                // distributorMap을 사용하여 distributorName으로 변환
	                distributorElement.value = distributorMap[distributorNo] || distributorNo;
	            }
	        }
	        
	        /**
	         * ## 기능 및 기술 요약
	         *
	         * ### 기능
	         * - 주어진 `authorNo`에 대해 문서를 회수하는 기능을 수행
	         * - `authorNo` 값이 없다면 경고창을 띄우고 종료
	         * - 회수 진행 전에 사용자의 확인을 요청
	         * - 서버로 문서 회수 요청을 보내고, 성공적으로 회수되면 알림을 제거
	         * - 문서 회수 후, 성공적으로 완료되면 리스트 페이지로 리디렉션
	         *
	         * ### 기술
	         * - **CSRF 토큰 처리**: 요청 헤더에 CSRF 토큰을 포함하여 보안 강화
	         * - **알림 제거**: 문서 회수 후 알림을 제거하는 추가적인 fetch 호출
	         * - **조건문 및 사용자 확인**: 문서 번호가 존재하지 않거나 회수 여부를 사용자가 확인해야 하는 기능
	         */
	        function recallDocument() {
	            const authorNo = document.getElementById('authorNo').value;
	            console.log('authorNo 값:', authorNo);  // 콘솔에 값이 출력되는지 확인

	            if (!authorNo) {
	                alert('문서 번호를 찾을 수 없습니다.');
	                return;
	            }

	            if (confirm('정말 이 문서를 회수하시겠습니까?')) {
	                const csrfToken = document.querySelector('meta[name="_csrf"]').getAttribute('content');
	                const csrfHeader = document.querySelector('meta[name="_csrf_header"]').getAttribute('content');

	                fetch(`/authorization/recall`, {
	                    method: 'POST',
	                    headers: {
	                        'Content-Type': 'application/json',
	                        [csrfHeader]: csrfToken
	                    },
	                    body: JSON.stringify({
	                        authorNo: authorNo  // 여기서 authorNo를 서버로 전달
	                    })
	                })
	                .then(response => {
	                    if (!response.ok) {
	                        throw new Error('문서 회수에 실패했습니다.');
	                    }
	                    return response.text();
	                })
	                .then(data => {
	                    alert('문서가 회수되었습니다.');
	                    
	                    // 알림을 제거하는 fetch 호출 추가
	                    fetch(`/authorization/clearAuthorNotification/${authorNo}`, {
	                        method: 'GET',
	                        headers: {
	                            'X-CSRF-TOKEN': csrfToken
	                        }
	                    })
	                    .then(response => {
	                        if (response.ok) {
	                            console.log('알림이 성공적으로 제거되었습니다.');
	                            // 알림 배지 숨기기 로직
	                            const authorBadge = document.getElementById("author-list-link").querySelector('.notification-badge');
	                            if (authorBadge) {
	                                authorBadge.style.display = 'none';
	                            }
	                            const mainNotification = document.getElementById("main-notification");
	                            if (mainNotification) {
	                                mainNotification.style.display = 'none';
	                            }
	                        } else {
	                            throw new Error('알림 제거 요청이 실패했습니다.');
	                        }
	                    })
	                    .catch(error => {
	                        console.error('Error clearing notification:', error);
	                    });

	                    // 페이지 리디렉션
	                    window.location.href = "/authorization/authorizationList";
	                })
	                .catch(error => {
	                    console.error('Error:', error);
	                    alert('문서 회수 중 오류가 발생했습니다.');
	                });
	            }
	        }

	        /**
	         * ## 기능 및 기술 요약
	         *
	         * ### 기능
	         * - 주어진 `authorNo`에 대해 알림을 제거하는 기능을 수행
	         * - CSRF 토큰을 포함하여 알림 제거 요청을 서버로 전송
	         * - 응답 상태 코드와 알림 배지 및 메인 알림의 표시 여부를 로그로 기록
	         * - 성공적으로 알림이 제거되면 UI에서 알림 배지와 메인 알림을 숨김 처리
	         *
	         * ### 기술
	         * - **CSRF 토큰 처리**: 보안을 강화하기 위해 요청 헤더에 CSRF 토큰을 포함
	         * - **디버깅을 위한 로그**: 각 단계에서 데이터를 로깅하여 문제 해결에 유용한 정보를 제공
	         * - **DOM 조작**: 알림 배지 및 메인 알림의 표시를 제어하는 로직
	         */
		    // 완료 문서 알람 표기
			function clearNotification(authorNo) {
			    // 로그 추가: authorNo 확인
			    console.log('clearNotification 호출됨, authorNo:', authorNo);
			
			    // CSRF Token 로그 추가
			    console.log('CSRF Token:', csrfToken);
			
			    fetch(`/authorization/clearAuthorNotification/${authorNo}`, {
			        method: 'GET',
			        headers: {
			            'X-CSRF-TOKEN': csrfToken
			        }
			    })
			    .then(response => {
			        // 응답 상태 코드 로그 추가
			        console.log('응답 상태 코드:', response.status);
			
			        if (response.ok) {
			            console.log('알림이 성공적으로 제거되었습니다.');
			            
			            // 알림 배지를 숨김 처리
			            const authorBadge = document.getElementById("author-list-link").querySelector('.notification-badge');
			            console.log('authorBadge 요소:', authorBadge);  // 알림 배지 확인
			            if (authorBadge) {
			                authorBadge.style.display = 'none';
			                console.log('알림 배지가 숨겨졌습니다.');
			            } else {
			                console.log('알림 배지 요소를 찾을 수 없습니다.');
			            }
			
			            const mainNotification = document.getElementById("main-notification");
			            console.log('mainNotification 요소:', mainNotification);  // 메인 알림 확인
			            if (mainNotification) {
			                mainNotification.style.display = 'none';
			                console.log('메인 알림이 숨겨졌습니다.');
			            } else {
			                console.log('메인 알림 요소를 찾을 수 없습니다.');
			            }
			        } else {
			            throw new Error('알림 제거 요청이 실패했습니다.');
			        }
			    })
			    .catch(error => {
			        console.error('Error clearing notification:', error);
			    });
			}
		</script>

     </th:block>
</html>
